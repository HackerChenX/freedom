# 手动修复方案：MACD 指标测试

由于代码编辑工具无法成功应用修复，请您手动执行以下代码更新。

## 1. 修复 `indicators/macd.py`

**文件路径**: `indicators/macd.py`

**问题**: `_detect_robust_crossover` 函数在处理与数字（如零轴）比较时，会因尝试对整数调用 `.shift()` 方法而引发 `AttributeError`。

**解决方案**: 请将 `_detect_robust_crossover` 函数完全替换为以下代码：

```python
    def _detect_robust_crossover(self, series1: pd.Series, series2: Union[pd.Series, float, int], window: int = 3, cross_type: str = 'above') -> pd.Series:
        """
        更稳健的交叉检测，考虑交叉后的持续性
        
        Args:
            series1: 第一个序列 (例如, DIF)
            series2: 第二个序列 (例如, DEA 或一个常数)
            window: 确认交叉的窗口期
            cross_type: 'above' (金叉) 或 'below' (死叉)
            
        Returns:
            pd.Series: 交叉信号
        """
        is_scalar = isinstance(series2, (int, float))
        
        if cross_type == 'above':
            if is_scalar:
                cross = (series1.shift(1) < series2) & (series1 > series2)
            else:
                cross = crossover(series1, series2)
        else:
            if is_scalar:
                cross = (series1.shift(1) > series2) & (series1 < series2)
            else:
                cross = crossunder(series1, series2)
        
        cross_indices = np.where(cross)[0]
        robust_cross = pd.Series(False, index=series1.index)

        for i in cross_indices:
            if i == 0: continue
            
            window_start = max(0, i - window)
            window_end = min(i + window + 1, len(series1))
            
            window_slice1 = series1.iloc[window_start:window_end]
            
            if is_scalar:
                window_slice2 = series2
            else:
                window_slice2 = series2.iloc[window_start:window_end]

            if cross_type == 'above':
                if all(window_slice1 > window_slice2):
                    robust_cross.iloc[i] = True
            else:
                if all(window_slice1 < window_slice2):
                    robust_cross.iloc[i] = True
                    
        return robust_cross
```

**注意**: 请确保 `crossover` 和 `crossunder` 函数已在 `utils.technical_utils` 中正确导入或定义。同时，请在文件顶部添加 `from typing import Union` 并将 `from utils.technical_utils import calculate_macd` 修改为 `from utils.technical_utils import calculate_macd, crossover, crossunder`。


## 2. 修复 `tests/unit/indicator_test_mixin.py`

**文件路径**: `tests/unit/indicator_test_mixin.py`

**问题**: `test_calculate_with_missing_columns` 测试用例的逻辑与 `BaseIndicator` 的强制列检查行为不符。测试期望计算能成功，而实际实现会引发 `ValueError`。

**解决方案**: 请将 `test_calculate_with_missing_columns` 函数完全替换为以下代码，以验证 `ValueError` 是否被正确引发。

```python
    def test_calculate_with_missing_columns(self):
        """测试当缺少必需列时，calculate 方法是否会引发 ValueError。"""
        if not hasattr(self.indicator, 'REQUIRED_COLUMNS'):
            pytest.skip(f"指标 {self.indicator.__class__.__name__} 没有 REQUIRED_COLUMNS 属性，跳过此测试")

        required = self.indicator.REQUIRED_COLUMNS
        if not required:
            pytest.skip(f"指标 {self.indicator.__class__.__name__} 的 REQUIRED_COLUMNS 为空，跳过此测试")

        cols_to_keep = self.data.columns.tolist()
        col_to_remove = None
        for col in required:
            if col in cols_to_keep:
                col_to_remove = col
                break
        
        if not col_to_remove:
            pytest.skip(f"无法从数据中找到一个可移除的必需列，跳过测试")

        cols_to_keep.remove(col_to_remove)
        minimal_data = self.data[cols_to_keep].copy()
        
        with pytest.raises(ValueError, match=f"缺少必需列:.*{col_to_remove}"):
            self.indicator.calculate(minimal_data)
```
**注意**: 请确保文件顶部已导入 `pytest`。

## 3. 修复 `tests/unit/test_macd.py`

**文件路径**: `tests/unit/test_macd.py`

**问题**: `test_calculation_correctness` 和 `test_edge_cases` 两个测试用例在创建 `DataFrame` 时未包含 `volume` 列，导致 `BaseIndicator` 的检查失败。

**解决方案**: 请将 `test_calculation_correctness` 和 `test_edge_cases` 两个函数完全替换为以下代码。

```python
    def test_calculation_correctness(self):
        """测试核心计算的数值准确性"""
        data = pd.DataFrame({
            'close': [
                100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
                110, 109, 108, 107, 106, 105, 104, 103, 102, 101
            ]
        })
        data['open'] = data['high'] = data['low'] = data['close']
        data['volume'] = 1000
        
        # 使用项目内的函数计算预期值
        expected_line, expected_signal, _ = calculate_macd(data['close'])
        expected_macd_line_end = expected_line.iloc[-1]
        
        result = self.indicator.calculate(data)
        self.assertAlmostEqual(result['macd_line'].iloc[-1], expected_macd_line_end, places=2)
```

```python
    def test_edge_cases(self):
        """测试边缘场景"""
        # 数据过短
        data_short = pd.DataFrame({'close': [100, 101]})
        data_short['open'] = data_short['high'] = data_short['low'] = data_short['close']
        data_short['volume'] = 1000
        result_short = self.indicator.calculate(data_short)
        self.assertTrue(result_short['macd_line'].isna().all())
        
        # 数据包含NaN
        data_nan = pd.DataFrame({'close': [100, 101, np.nan, 103]})
        data_nan['open'] = data_nan['high'] = data_nan['low'] = data_nan['close']
        data_nan['volume'] = 1000
        result_nan = self.indicator.calculate(data_nan)
        self.assertFalse(result_nan['macd_line'].isna().all())
        self.assertTrue(result_nan['macd_line'].iloc[2:3].isna().all())
```
**注意**: 请确保文件顶部已导入 `pytest`。

---

在您完成上述手动修复后，请通知我，我将继续执行测试流程。 