# 技术指标打分机制设计文档

## 1. 总体设计

技术指标打分机制是一个统一的评分系统，用于量化各种技术指标的信号强度和可靠性，并提供标准化的输出格式。该系统遵循以下核心原则：

### 1.1 评分标准

- **评分范围**：所有指标信号评分统一使用0-100的范围，其中：
  - 0-20：极度看跌
  - 21-40：看跌
  - 41-60：中性
  - 61-80：看涨
  - 81-100：极度看涨

- **基础分值**：
  - 中性状态基础分为50分
  - 每种买入信号一般增加10-25分
  - 每种卖出信号一般减少10-25分
  - 重要形态确认和多重信号叠加可额外增减分数

- **信号权重**：
  - 主要信号（如金叉/死叉）权重较高
  - 辅助信号（如柱状图颜色变化）权重较低
  - 高级形态（如背离、突破）权重最高

### 1.2 市场环境适应性机制

为了提高打分机制的准确性，系统引入了市场环境识别和动态权重调整机制：

#### 1.2.1 市场环境分类
- **牛市环境**：趋势指标权重提高，震荡指标权重降低
- **熊市环境**：防守性指标权重提高，风险控制加强
- **震荡市环境**：震荡指标权重提高，趋势指标权重降低
- **突破行情**：成交量指标和波动率指标权重显著提高

#### 1.2.2 动态权重配置
```python
MARKET_ENVIRONMENT_WEIGHTS = {
    "bull_market": {
        "trend_indicators": 0.45,
        "oscillator_indicators": 0.25,
        "volume_indicators": 0.20,
        "volatility_indicators": 0.10
    },
    "bear_market": {
        "trend_indicators": 0.30,
        "oscillator_indicators": 0.40,
        "volume_indicators": 0.15,
        "volatility_indicators": 0.15
    },
    "sideways_market": {
        "trend_indicators": 0.20,
        "oscillator_indicators": 0.50,
        "volume_indicators": 0.20,
        "volatility_indicators": 0.10
    },
    "breakout_market": {
        "trend_indicators": 0.35,
        "oscillator_indicators": 0.20,
        "volume_indicators": 0.30,
        "volatility_indicators": 0.15
    }
}
```

#### 1.2.3 市场环境识别算法
```python
def detect_market_environment(price_data, volume_data, lookback_period=60):
    """
    市场环境识别算法
    
    Returns:
        str: 市场环境类型 ('bull_market', 'bear_market', 'sideways_market', 'breakout_market')
    """
    # 1. 趋势强度分析
    trend_strength = calculate_trend_strength(price_data, lookback_period)
    
    # 2. 波动率分析
    volatility = calculate_volatility(price_data, lookback_period)
    
    # 3. 成交量分析
    volume_trend = analyze_volume_trend(volume_data, lookback_period)
    
    # 4. 价格动量分析
    momentum = calculate_momentum(price_data, lookback_period)
    
    # 5. 综合判断
    if trend_strength > 0.7 and momentum > 0.5:
        return "bull_market"
    elif trend_strength < -0.7 and momentum < -0.5:
        return "bear_market"
    elif volatility > 0.8 and volume_trend > 0.6:
        return "breakout_market"
    else:
        return "sideways_market"
```

### 1.3 信号输出格式

所有指标的`generate_signals`方法将输出统一格式的信号DataFrame，包含以下标准列：

- `buy_signal`：布尔值，表示买入信号
- `sell_signal`：布尔值，表示卖出信号
- `neutral_signal`：布尔值，表示中性信号
- `trend`：整数，表示趋势方向（-1: 下降，0: 中性，1: 上升）
- `score`：整数，表示综合信号强度（0-100）
- `signal_type`：字符串，表示具体的信号类型
- `signal_desc`：字符串，表示信号的详细描述
- `confidence`：浮点数，表示信号置信度（0-100）
- `risk_level`：字符串，表示风险等级（'低', '中', '高'）
- `position_size`：浮点数，建议仓位比例（0-1）
- `stop_loss`：浮点数，建议止损位
- `market_env`：字符串，当前市场环境
- `volume_confirmation`：布尔值，成交量是否确认信号

### 1.4 风险控制集成

#### 1.4.1 动态止损计算
```python
def calculate_dynamic_stop_loss(price_data, atr_data, signal_score, signal_type):
    """
    计算动态止损位
    """
    current_price = price_data.iloc[-1]
    current_atr = atr_data.iloc[-1]
    
    # 基于信号强度调整止损距离
    if signal_score >= 80:
        atr_multiplier = 1.5  # 强信号，较宽止损
    elif signal_score >= 60:
        atr_multiplier = 2.0  # 中等信号，中等止损
    else:
        atr_multiplier = 2.5  # 弱信号，较紧止损
    
    if signal_type == 'buy':
        stop_loss = current_price - (current_atr * atr_multiplier)
    else:
        stop_loss = current_price + (current_atr * atr_multiplier)
    
    return stop_loss
```

#### 1.4.2 仓位管理
```python
def calculate_position_size(signal_score, account_balance, risk_per_trade=0.02):
    """
    根据信号强度计算仓位大小
    """
    base_position = risk_per_trade
    
    if signal_score >= 85:
        position_multiplier = 2.0  # 极强信号，加大仓位
    elif signal_score >= 70:
        position_multiplier = 1.5  # 强信号，适度加仓
    elif signal_score >= 60:
        position_multiplier = 1.0  # 中等信号，正常仓位
    elif signal_score >= 50:
        position_multiplier = 0.7  # 弱信号，减少仓位
    else:
        position_multiplier = 0.3  # 很弱信号，最小仓位
    
    final_position = base_position * position_multiplier
    max_position = 0.1  # 单笔交易最大10%仓位
    return min(final_position, max_position)
```

## 2. 趋势指标打分机制

### 2.1 移动平均线(MA)

#### 简单移动平均线(SMA)
- **基础评分规则**：
  - 基础分：50分（中性）
  - 价格上穿MA：+20分
  - 价格下穿MA：-20分
  - 短期MA上穿长期MA：+15分
  - 短期MA下穿长期MA：-15分
  - 多均线多头排列（由短至长向上）：+10分
  - 多均线空头排列（由短至长向下）：-10分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 价格与均线关系
  if price > ma:
      score += 10
  elif price < ma:
      score -= 10
      
  # 价格穿越均线
  if crossover(price, ma):
      score += 20
  elif crossunder(price, ma):
      score -= 20
      
  # 均线趋势
  if ma斜率 > 0:
      score += 5
  elif ma斜率 < 0:
      score -= 5
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

#### 指数移动平均线(EMA)
- **基础评分规则**：与SMA类似，但对近期价格变化反应更敏感
  - 基础分：50分（中性）
  - 价格上穿EMA：+25分（比SMA权重更高）
  - 价格下穿EMA：-25分
  - 短期EMA上穿长期EMA：+20分
  - 短期EMA下穿长期EMA：-20分
  - 多均线多头排列：+15分
  - 多均线空头排列：-15分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 价格与均线关系
  if price > ema:
      score += 12
  elif price < ema:
      score -= 12
      
  # 价格穿越均线
  if crossover(price, ema):
      score += 25
  elif crossunder(price, ema):
      score -= 25
      
  # 均线趋势
  if ema斜率 > 0:
      score += 8
  elif ema斜率 < 0:
      score -= 8
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

#### 加权移动平均线(WMA)
- **基础评分规则**：
  - 基础分：50分（中性）
  - 价格上穿WMA：+22分
  - 价格下穿WMA：-22分
  - 短期WMA上穿长期WMA：+18分
  - 短期WMA下穿长期WMA：-18分
  - 多均线多头排列：+12分
  - 多均线空头排列：-12分

#### 统一移动平均线(UnifiedMA)
- **基础评分规则**：整合了多种MA的综合评分
  - 基础分：50分（中性）
  - 价格位于多数MA之上：+5-15分（视MA数量而定）
  - 价格位于多数MA之下：-5-15分
  - 短期MA组上穿长期MA组：+18分
  - 短期MA组下穿长期MA组：-18分
  - 全部MA多头排列：+20分
  - 全部MA空头排列：-20分
  - MA带形成通道且价格突破通道上轨：+25分
  - MA带形成通道且价格突破通道下轨：-25分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 计算价格与各MA的关系
  above_count = 价格高于的MA数量
  below_count = 价格低于的MA数量
  ma_count = MA总数
  
  # 价格位置评分
  price_position_score = (above_count - below_count) / ma_count * 15
  score += price_position_score
  
  # MA排列形态
  if 检测到多头排列():
      score += 10 + 多头排列的完美度 * 10  # 最多+20分
  elif 检测到空头排列():
      score -= 10 + 空头排列的完美度 * 10  # 最多-20分
      
  # MA交叉信号
  if 检测到短期MA组上穿长期MA组():
      score += 18
  elif 检测到短期MA组下穿长期MA组():
      score -= 18
  
  # 通道突破
  if 检测到价格突破MA通道上轨():
      score += 25
  elif 检测到价格突破MA通道下轨():
      score -= 25
  
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 2.2 MACD指标

#### 标准MACD
- **基础评分规则**：
  - 基础分：50分（中性）
  - DIF上穿DEA（金叉）：+20分
  - DIF下穿DEA（死叉）：-20分
  - DIF和DEA同时位于零轴上方：+10分
  - DIF和DEA同时位于零轴下方：-10分
  - DIF上穿零轴：+15分
  - DIF下穿零轴：-15分
  - MACD柱状图由负转正：+12分
  - MACD柱状图由正转负：-12分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 金叉/死叉
  if DIF上穿DEA:
      score += 20
  elif DIF下穿DEA:
      score -= 20
      
  # 零轴位置
  if DIF > 0 and DEA > 0:
      score += 10
  elif DIF < 0 and DEA < 0:
      score -= 10
      
  # 零轴穿越
  if DIF上穿零轴:
      score += 15
  elif DIF下穿零轴:
      score -= 15
      
  # 柱状图变化
  if MACD柱状图由负转正:
      score += 12
  elif MACD柱状图由正转负:
      score -= 12
      
  # 限制得分范围
  score = max(0, min(100, score))
  ``` 

#### 增强型MACD (EnhancedMACD)
- **基础评分规则**：在标准MACD基础上增加背离判断
  - 基础分：50分（中性）
  - DIF上穿DEA（金叉）：+20分
  - DIF下穿DEA（死叉）：-20分
  - DIF和DEA同时位于零轴上方：+10分
  - DIF和DEA同时位于零轴下方：-10分
  - DIF上穿零轴：+15分
  - DIF下穿零轴：-15分
  - MACD柱状图由负转正：+12分
  - MACD柱状图由正转负：-12分
  - MACD正背离：+25分
  - MACD负背离：-25分
  - 隐藏正背离：+20分
  - 隐藏负背离：-20分
  - 双重MACD确认：额外±15分
  - MACD能量强度：根据能量大小额外±10分

- **详细打分机制**：
  ```python
  def calculate_enhanced_macd_score(macd_data, price_data):
      """
      增强型MACD打分机制
      """
      score = 50  # 基础分
      
      dif = macd_data['DIF']
      dea = macd_data['DEA']
      macd_hist = macd_data['MACD']
      
      # 1. 基础信号评分
      if crossover(dif, dea):
          score += 20  # 金叉
      elif crossunder(dif, dea):
          score -= 20  # 死叉
      
      # 2. 零轴位置评分
      if dif.iloc[-1] > 0 and dea.iloc[-1] > 0:
          score += 10
      elif dif.iloc[-1] < 0 and dea.iloc[-1] < 0:
          score -= 10
      
      # 3. 零轴穿越评分
      if crossover(dif, 0):
          score += 15
      elif crossunder(dif, 0):
          score -= 15
      
      # 4. MACD柱状图评分
      if macd_hist.iloc[-1] > 0 and macd_hist.iloc[-2] <= 0:
          score += 12  # 由负转正
      elif macd_hist.iloc[-1] < 0 and macd_hist.iloc[-2] >= 0:
          score -= 12  # 由正转负
      
      # 5. 能量强度评分
      energy_score = calculate_macd_energy(macd_hist)
      if dif.iloc[-1] > dea.iloc[-1]:  # 看涨趋势
          score += energy_score * 10
      else:  # 看跌趋势
          score -= energy_score * 10
      
      # 6. 背离检测评分
      divergence_strength = calculate_divergence_strength(dif, price_data)
      if divergence_strength > 0.5:  # 正背离
          score += 25
      elif divergence_strength < -0.5:  # 负背离
          score -= 25
      
      # 7. 隐藏背离检测
      hidden_div = detect_hidden_divergence(dif, price_data)
      if hidden_div == 'bullish':
          score += 20
      elif hidden_div == 'bearish':
          score -= 20
      
      # 8. 交叉质量评分
      cross_quality = evaluate_cross_quality(dif, dea, macd_hist)
      score += cross_quality
      
      return max(0, min(100, score))
  
  def calculate_macd_energy(macd_hist):
      """
      计算MACD能量强度
      """
      # 1. MACD柱状图面积（能量大小）
      recent_hist = macd_hist[-10:]  # 最近10个周期
      energy_area = abs(recent_hist).sum()
      
      # 2. MACD变化率（能量变化速度）
      hist_change_rate = abs(macd_hist.diff()).rolling(5).mean().iloc[-1]
      
      # 3. 归一化能量值
      normalized_energy = min(1.0, energy_area / 100 + hist_change_rate / 10)
      
      return normalized_energy
  
  def calculate_divergence_strength(indicator_data, price_data, lookback=20):
      """
      计算背离强度
      """
      # 寻找价格和指标的峰值/谷值
      price_peaks = find_peaks_and_troughs(price_data, lookback)
      indicator_peaks = find_peaks_and_troughs(indicator_data, lookback)
      
      # 比较最近的峰值/谷值趋势
      if len(price_peaks) >= 2 and len(indicator_peaks) >= 2:
          price_trend = price_peaks[-1] - price_peaks[-2]
          indicator_trend = indicator_peaks[-1] - indicator_peaks[-2]
          
          # 计算背离强度
          if price_trend > 0 and indicator_trend < 0:
              return -abs(price_trend - indicator_trend) / max(abs(price_trend), abs(indicator_trend))
          elif price_trend < 0 and indicator_trend > 0:
              return abs(price_trend - indicator_trend) / max(abs(price_trend), abs(indicator_trend))
      
      return 0
  
  def evaluate_cross_quality(dif, dea, macd_hist):
      """
      评估交叉质量
      """
      quality_score = 0
      
      # 1. 交叉角度（角度越大质量越高）
      if len(dif) >= 3:
          dif_slope = (dif.iloc[-1] - dif.iloc[-3]) / 2
          dea_slope = (dea.iloc[-1] - dea.iloc[-3]) / 2
          angle_diff = abs(dif_slope - dea_slope)
          quality_score += min(5, angle_diff * 10)
      
      # 2. 交叉位置（零轴附近交叉质量更高）
      cross_position = abs(dif.iloc[-1])
      if cross_position < 0.1:  # 接近零轴
          quality_score += 5
      elif cross_position < 0.2:
          quality_score += 3
      
      # 3. MACD柱状图确认
      if macd_hist.iloc[-1] * (dif.iloc[-1] - dea.iloc[-1]) > 0:
          quality_score += 3  # 柱状图与交叉方向一致
      
      return quality_score
  ```

## 3. 震荡指标打分机制

### 3.1 相对强弱指标(RSI)

#### 标准RSI
- **基础评分规则**：
  - 基础分：50分（中性）
  - RSI值 < 30：+15-30分（越低加分越多）
  - RSI值 > 70：-15-30分（越高减分越多）
  - RSI上穿30：+20分
  - RSI下穿70：-20分
  - RSI形成底背离：+25分
  - RSI形成顶背离：-25分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 超买超卖区
  if rsi <= 30:
      oversold_points = max(15, min(30, 30 - rsi))  # 最多+30分
      score += oversold_points
  elif rsi >= 70:
      overbought_points = max(15, min(30, rsi - 70))  # 最多-30分
      score -= overbought_points
      
  # RSI穿越
  if rsi_crossover_30:
      score += 20
  elif rsi_crossunder_70:
      score -= 20
      
  # RSI背离
  if rsi_bullish_divergence:
      score += 25
  elif rsi_bearish_divergence:
      score -= 25
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

#### 增强型RSI (EnhancedRSI)
- **基础评分规则**：在标准RSI基础上增加多周期判断
  - 基础分：50分（中性）
  - 同标准RSI的规则
  - 多周期RSI确认看涨：+10-20分
  - 多周期RSI确认看跌：-10-20分
  - RSI形成"W底"形态：+25分
  - RSI形成"M顶"形态：-25分
  - RSI中心线(50)穿越：±15分
  - 动态超买超卖阈值：根据市场波动率调整
  - RSI斜率确认：±10分

- **详细打分机制**：
  ```python
  def calculate_enhanced_rsi_score(rsi_data, price_data, volatility_data):
      """
      增强型RSI打分机制
      """
      score = 50  # 基础分
      
      current_rsi = rsi_data.iloc[-1]
      rsi_14 = rsi_data  # 14周期RSI
      
      # 1. 动态超买超卖阈值
      dynamic_thresholds = calculate_dynamic_rsi_thresholds(volatility_data)
      oversold_threshold = dynamic_thresholds['oversold']
      overbought_threshold = dynamic_thresholds['overbought']
      
      # 2. 基础超买超卖评分
      if current_rsi <= oversold_threshold:
          oversold_intensity = (oversold_threshold - current_rsi) / oversold_threshold
          score += min(30, 15 + oversold_intensity * 15)
      elif current_rsi >= overbought_threshold:
          overbought_intensity = (current_rsi - overbought_threshold) / (100 - overbought_threshold)
          score -= min(30, 15 + overbought_intensity * 15)
      
      # 3. RSI穿越评分
      if crossover(rsi_14, oversold_threshold):
          score += 20
      elif crossunder(rsi_14, overbought_threshold):
          score -= 20
      
      # 4. 中心线穿越
      if crossover(rsi_14, 50):
          score += 15
      elif crossunder(rsi_14, 50):
          score -= 15
      
      # 5. 多周期RSI确认
      multi_period_score = calculate_multi_period_rsi_confirmation(price_data)
      score += multi_period_score
      
      # 6. RSI背离检测
      divergence_score = detect_rsi_divergence(rsi_14, price_data)
      score += divergence_score
      
      # 7. 形态识别
      pattern_score = identify_rsi_patterns(rsi_14)
      score += pattern_score
      
      # 8. RSI斜率确认
      slope_score = calculate_rsi_slope_score(rsi_14)
      score += slope_score
      
      return max(0, min(100, score))
  
  def calculate_dynamic_rsi_thresholds(volatility_data):
      """
      根据市场波动率动态调整RSI超买超卖阈值
      """
      current_volatility = volatility_data.iloc[-1]
      avg_volatility = volatility_data.rolling(60).mean().iloc[-1]
      
      volatility_ratio = current_volatility / avg_volatility
      
      # 高波动率时放宽阈值，低波动率时收紧阈值
      if volatility_ratio > 1.5:  # 高波动率
          oversold = 25
          overbought = 75
      elif volatility_ratio > 1.2:  # 中高波动率
          oversold = 28
          overbought = 72
      elif volatility_ratio < 0.8:  # 低波动率
          oversold = 35
          overbought = 65
      else:  # 正常波动率
          oversold = 30
          overbought = 70
      
      return {'oversold': oversold, 'overbought': overbought}
  
  def calculate_multi_period_rsi_confirmation(price_data):
      """
      多时间周期RSI确认
      """
      # 计算不同周期的RSI
      rsi_9 = calculate_rsi(price_data, 9)
      rsi_14 = calculate_rsi(price_data, 14)
      rsi_21 = calculate_rsi(price_data, 21)
      
      current_rsi_9 = rsi_9.iloc[-1]
      current_rsi_14 = rsi_14.iloc[-1]
      current_rsi_21 = rsi_21.iloc[-1]
      
      # 计算RSI趋势一致性
      rsi_values = [current_rsi_9, current_rsi_14, current_rsi_21]
      
      # 判断趋势方向
      bullish_count = sum(1 for rsi in rsi_values if rsi > 50)
      bearish_count = sum(1 for rsi in rsi_values if rsi < 50)
      
      if bullish_count == 3:
          return 20  # 全部看涨
      elif bullish_count == 2:
          return 10  # 多数看涨
      elif bearish_count == 3:
          return -20  # 全部看跌
      elif bearish_count == 2:
          return -10  # 多数看跌
      else:
          return 0  # 中性
  
  def detect_rsi_divergence(rsi_data, price_data):
      """
      RSI背离检测
      """
      # 寻找RSI和价格的峰值谷值
      rsi_peaks = find_peaks_and_troughs(rsi_data, 20)
      price_peaks = find_peaks_and_troughs(price_data, 20)
      
      if len(rsi_peaks) >= 2 and len(price_peaks) >= 2:
          # 比较最近两个峰值/谷值
          rsi_trend = rsi_peaks[-1] - rsi_peaks[-2]
          price_trend = price_peaks[-1] - price_peaks[-2]
          
          # 正背离：价格创新低但RSI未创新低
          if price_trend < 0 and rsi_trend > 0:
              return 25
          # 负背离：价格创新高但RSI未创新高
          elif price_trend > 0 and rsi_trend < 0:
              return -25
      
      return 0
  
  def identify_rsi_patterns(rsi_data):
      """
      RSI形态识别
      """
      if len(rsi_data) < 20:
          return 0
      
      recent_rsi = rsi_data[-20:]
      
      # W底形态检测
      if detect_w_bottom_pattern(recent_rsi):
          return 25
      
      # M顶形态检测
      if detect_m_top_pattern(recent_rsi):
          return -25
      
      return 0
  
  def calculate_rsi_slope_score(rsi_data):
      """
      计算RSI斜率得分
      """
      if len(rsi_data) < 5:
          return 0
      
      # 计算最近5个周期的RSI斜率
      recent_rsi = rsi_data[-5:]
      slope = (recent_rsi.iloc[-1] - recent_rsi.iloc[0]) / 4
      
      # 斜率越陡峭，得分越高
      if slope > 2:
          return 10  # 强烈上升
      elif slope > 1:
          return 5   # 温和上升
      elif slope < -2:
          return -10 # 强烈下降
      elif slope < -1:
          return -5  # 温和下降
      else:
          return 0   # 平缓
  ```

### 3.2 随机指标(KDJ)

- **基础评分规则**：
  - 基础分：50分（中性）
  - K线上穿D线：+20分
  - K线下穿D线：-20分
  - KDJ三线同时位于超买区（>80）：-25分
  - KDJ三线同时位于超卖区（<20）：+25分
  - K值从超卖区上升：+15分
  - K值从超买区下降：-15分
  - J线位于极端超买区（>100）：-30分
  - J线位于极端超卖区（<0）：+30分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # K和D线交叉
  if k_crossover_d:
      score += 20
  elif k_crossunder_d:
      score -= 20
      
  # 超买超卖区
  if k < 20 and d < 20 and j < 20:
      score += 25
  elif k > 80 and d > 80 and j > 80:
      score -= 25
      
  # K线区域变化
  if k_leaving_oversold:  # K值从<20升至>20
      score += 15
  elif k_leaving_overbought:  # K值从>80降至<80
      score -= 15
      
  # J线极端区域
  if j > 100:
      score -= 30
  elif j < 0:
      score += 30
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 3.3 威廉指标(Williams %R)

- **基础评分规则**：
  - 基础分：50分（中性）
  - WR值 < -80：+20分（超卖）
  - WR值 > -20：-20分（超买）
  - WR从超卖区上穿-80：+25分
  - WR从超买区下穿-20：-25分
  - WR形成底背离：+30分
  - WR形成顶背离：-30分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 超买超卖区
  if wr < -80:
      score += 20
  elif wr > -20:
      score -= 20
      
  # 区域穿越
  if wr_crossover_minus80:
      score += 25
  elif wr_crossunder_minus20:
      score -= 25
      
  # 背离
  if wr_bullish_divergence:
      score += 30
  elif wr_bearish_divergence:
      score -= 30
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 3.4 CCI指标

- **基础评分规则**：
  - 基础分：50分（中性）
  - CCI值 < -100：+20分（超卖）
  - CCI值 > +100：-20分（超买）
  - CCI上穿-100：+25分
  - CCI下穿+100：-25分
  - CCI形成底背离：+30分
  - CCI形成顶背离：-30分
  - CCI上穿零轴：+15分
  - CCI下穿零轴：-15分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 超买超卖区
  if cci < -100:
      score += 20
  elif cci > 100:
      score -= 20
      
  # 区域穿越
  if cci_crossover_minus100:
      score += 25
  elif cci_crossunder_plus100:
      score -= 25
      
  # 零轴穿越
  if cci_crossover_zero:
      score += 15
  elif cci_crossunder_zero:
      score -= 15
      
  # 背离
  if cci_bullish_divergence:
      score += 30
  elif cci_bearish_divergence:
      score -= 30
      
  # 限制得分范围
  score = max(0, min(100, score))
  ``` 

## 4. 成交量指标打分机制

### 4.1 量价关系综合分析

在成交量指标评分中，量价关系是核心要素。系统采用多维度量价分析框架：

#### 4.1.1 量价配合度评分
```python
def calculate_volume_price_harmony_score(price_data, volume_data):
    """
    计算量价配合度评分
    """
    score = 0
    
    # 1. 价格上涨 + 成交量放大
    price_change = price_data.pct_change()
    volume_change = volume_data.pct_change()
    
    recent_periods = 5
    for i in range(-recent_periods, 0):
        if price_change.iloc[i] > 0 and volume_change.iloc[i] > 0:
            # 价涨量增，正向配合
            harmony_strength = min(price_change.iloc[i], volume_change.iloc[i])
            score += harmony_strength * 10
        elif price_change.iloc[i] < 0 and volume_change.iloc[i] > 0:
            # 价跌量增，可能是洗盘或出货
            if abs(price_change.iloc[i]) < volume_change.iloc[i]:
                score += 5  # 可能是洗盘，轻微加分
            else:
                score -= 8  # 可能是出货，减分
        elif price_change.iloc[i] > 0 and volume_change.iloc[i] < 0:
            # 价涨量缩，可能是惯性上涨或资金不足
            score -= 5
        elif price_change.iloc[i] < 0 and volume_change.iloc[i] < 0:
            # 价跌量缩，可能是技术性调整
            score += 3
    
    return min(25, max(-25, score))

def detect_volume_patterns(volume_data, price_data):
    """
    检测成交量形态
    """
    patterns = {}
    
    # 1. 放量突破
    if detect_volume_breakout(volume_data, price_data):
        patterns['volume_breakout'] = 20
    
    # 2. 缩量整理
    if detect_volume_consolidation(volume_data, price_data):
        patterns['volume_consolidation'] = 10
    
    # 3. 天量天价/地量地价
    if detect_extreme_volume_price(volume_data, price_data):
        patterns['extreme_volume_price'] = 15
    
    # 4. 量价背离
    divergence_score = detect_volume_price_divergence(volume_data, price_data)
    if divergence_score != 0:
        patterns['volume_price_divergence'] = divergence_score
    
    return patterns
```

### 4.2 OBV (On-Balance Volume) - 增强版

- **基础评分规则**：
  - 基础分：50分（中性）
  - OBV与价格同向上涨：+15分
  - OBV与价格同向下跌：-15分
  - OBV与价格形成正背离：+25分
  - OBV与价格形成负背离：-25分
  - OBV突破前期高点：+20分
  - OBV跌破前期低点：-20分
  - OBV均线金叉：+15分
  - OBV均线死叉：-15分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # OBV趋势与价格趋势一致性
  if obv_trend > 0 and price_trend > 0:
      score += 15
  elif obv_trend < 0 and price_trend < 0:
      score -= 15
      
  # 背离
  if obv_bullish_divergence:
      score += 25
  elif obv_bearish_divergence:
      score -= 25
      
  # 突破
  if obv_breaking_high:
      score += 20
  elif obv_breaking_low:
      score -= 20
      
  # OBV均线交叉
  if obv_ma_golden_cross:
      score += 15
  elif obv_ma_death_cross:
      score -= 15
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 4.3 成交量比率(VR)

- **基础评分规则**：
  - 基础分：50分（中性）
  - VR < 70：+20分（可能超卖）
  - VR > 150：-20分（可能超买）
  - VR从低位开始上升：+15分
  - VR从高位开始下降：-15分
  - VR与价格形成正背离：+25分
  - VR与价格形成负背离：-25分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # VR值区间
  if vr < 70:
      score += 20
  elif vr > 150:
      score -= 20
      
  # VR趋势
  if vr_rising_from_low:
      score += 15
  elif vr_falling_from_high:
      score -= 15
      
  # 背离
  if vr_bullish_divergence:
      score += 25
  elif vr_bearish_divergence:
      score -= 25
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 4.4 能量潮指标(EMV)

- **基础评分规则**：
  - 基础分：50分（中性）
  - EMV > 0：+10分
  - EMV < 0：-10分
  - EMV上穿零轴：+20分
  - EMV下穿零轴：-20分
  - EMV与价格形成正背离：+25分
  - EMV与价格形成负背离：-25分
  - EMV值创新高：+15分
  - EMV值创新低：-15分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # EMV值区间
  if emv > 0:
      score += 10
  elif emv < 0:
      score -= 10
      
  # 零轴穿越
  if emv_crossover_zero:
      score += 20
  elif emv_crossunder_zero:
      score -= 20
      
  # 背离
  if emv_bullish_divergence:
      score += 25
  elif emv_bearish_divergence:
      score -= 25
      
  # 新高新低
  if emv_new_high:
      score += 15
  elif emv_new_low:
      score -= 15
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 4.5 资金流量指标(MFI)

- **基础评分规则**：
  - 基础分：50分（中性）
  - MFI < 20：+20分（超卖）
  - MFI > 80：-20分（超买）
  - MFI上穿20：+25分
  - MFI下穿80：-25分
  - MFI与价格形成正背离：+30分
  - MFI与价格形成负背离：-30分
  - MFI上穿50：+15分
  - MFI下穿50：-15分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 超买超卖区
  if mfi < 20:
      score += 20
  elif mfi > 80:
      score -= 20
      
  # 区域穿越
  if mfi_crossover_20:
      score += 25
  elif mfi_crossunder_80:
      score -= 25
      
  # 中线穿越
  if mfi_crossover_50:
      score += 15
  elif mfi_crossunder_50:
      score -= 15
      
  # 背离
  if mfi_bullish_divergence:
      score += 30
  elif mfi_bearish_divergence:
      score -= 30
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

## 5. 波动率指标打分机制

### 5.1 布林带(BOLL)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 价格触及上轨：-20分
  - 价格触及下轨：+20分
  - 价格突破上轨：-25分
  - 价格突破下轨：+25分
  - 布林带开口变大：±10分（视当前趋势而定）
  - 布林带开口变小：+5分（表示波动率降低）
  - 价格由下轨向中轨运行：+15分
  - 价格由上轨向中轨运行：-15分
  - 带宽指标极低：+15分（潜在突破）

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 价格位置
  if price >= upper_band:
      score -= 20
  elif price <= lower_band:
      score += 20
      
  # 突破
  if price_breaking_upper:
      score -= 25
  elif price_breaking_lower:
      score += 25
      
  # 价格运行
  if price_moving_lower_to_middle:
      score += 15
  elif price_moving_upper_to_middle:
      score -= 15
      
  # 带宽变化
  if bandwidth_expanding:
      if current_trend > 0:
          score += 10  # 上升趋势带宽扩大，趋势加强
      else:
          score -= 10  # 下降趋势带宽扩大，趋势加强
  elif bandwidth_contracting:
      score += 5  # 波动率降低，可能孕育新趋势
      
  # 带宽极低
  if bandwidth_extremely_low:
      score += 15  # 布林带收窄，可能即将突破
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 5.2 平均真实波幅(ATR)

- **基础评分规则**：
  - 基础分：50分（中性）
  - ATR值突然增大：±15分（视当前趋势而定）
  - ATR值持续降低：+5分（波动率降低，可能孕育新趋势）
  - 价格波动小于0.5倍ATR：+10分（潜在低吸机会）
  - 价格波动大于2倍ATR：-10分（可能过度波动）
  - ATR处于历史低位：+15分（可能即将突破）

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # ATR突然增大
  if atr_sudden_increase:
      if current_trend > 0:
          score += 15  # 上升趋势中ATR增大，趋势加强
      else:
          score -= 15  # 下降趋势中ATR增大，趋势加强
          
  # ATR持续降低
  if atr_continuously_decreasing:
      score += 5  # 波动率降低，可能孕育新趋势
      
  # 价格波动与ATR比较
  if price_volatility < 0.5 * atr:
      score += 10  # 波动小，可能是低吸机会
  elif price_volatility > 2 * atr:
      score -= 10  # 波动大，可能过度
      
  # ATR历史位置
  if atr_at_historical_low:
      score += 15  # ATR处于历史低位，可能即将突破
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 5.3 抛物线转向指标(SAR)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 价格上穿SAR：+30分（强烈买入信号）
  - 价格下穿SAR：-30分（强烈卖出信号）
  - 连续3个周期价格位于SAR上方：+15分
  - 连续3个周期价格位于SAR下方：-15分
  - SAR与价格距离扩大：+10分（趋势加强）
  - SAR反转时与价格距离较远：+15分（反转信号更可靠）

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 价格与SAR关系
  if price_crossover_sar:
      score += 30
  elif price_crossunder_sar:
      score -= 30
      
  # 持续趋势
  if price > sar for last 3 periods:
      score += 15
  elif price < sar for last 3 periods:
      score -= 15
      
  # SAR与价格距离
  if sar_price_distance_expanding and price > sar:
      score += 10  # 上升趋势加强
  elif sar_price_distance_expanding and price < sar:
      score -= 10  # 下降趋势加强
      
  # SAR反转信号强度
  if sar_reversal_with_large_distance:
      if price > sar:
          score += 15  # 反转向上信号更可靠
      else:
          score -= 15  # 反转向下信号更可靠
          
  # 限制得分范围
  score = max(0, min(100, score))
  ``` 

## 6. 模式识别指标打分机制

### 6.1 V型反转(V-Shaped Reversal)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 确认下降到上升V型反转：+40分
  - 确认上升到下降倒V型反转：-40分
  - V型反转的深度越大：额外±10分
  - 反转后的确认次数：每次确认额外±5分（最多3次）
  - 成交量配合（放量）：额外±10分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # V型反转确认
  if v_shaped_bullish_confirmed:
      score += 40
  elif inverted_v_shaped_bearish_confirmed:
      score -= 40
      
  # 反转深度
  depth_score = min(10, v_pattern_depth * 2)  # 最多±10分
  if v_shaped_bullish_confirmed:
      score += depth_score
  elif inverted_v_shaped_bearish_confirmed:
      score -= depth_score
      
  # 确认次数
  confirmation_score = min(15, confirmation_count * 5)  # 最多±15分
  if v_shaped_bullish_confirmed:
      score += confirmation_score
  elif inverted_v_shaped_bearish_confirmed:
      score -= confirmation_score
      
  # 成交量配合
  if v_shaped_bullish_confirmed and volume_confirmation:
      score += 10
  elif inverted_v_shaped_bearish_confirmed and volume_confirmation:
      score -= 10
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 6.2 平台突破(Platform Breakout)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 确认向上突破平台：+35分
  - 确认向下突破平台：-35分
  - 平台持续时间：每增加5个周期额外±5分（最多15分）
  - 突破幅度：幅度越大额外±10分
  - 成交量配合（放量突破）：额外±15分
  - 回测确认：额外±10分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 突破确认
  if upward_breakout_confirmed:
      score += 35
  elif downward_breakout_confirmed:
      score -= 35
      
  # 平台持续时间
  duration_periods = platform_duration / 5
  duration_score = min(15, duration_periods * 5)  # 最多±15分
  if upward_breakout_confirmed:
      score += duration_score
  elif downward_breakout_confirmed:
      score -= duration_score
      
  # 突破幅度
  breakout_magnitude_score = min(10, breakout_percentage * 2)  # 最多±10分
  if upward_breakout_confirmed:
      score += breakout_magnitude_score
  elif downward_breakout_confirmed:
      score -= breakout_magnitude_score
      
  # 成交量配合
  if upward_breakout_confirmed and volume_confirmation:
      score += 15
  elif downward_breakout_confirmed and volume_confirmation:
      score -= 15
      
  # 回测确认
  if upward_breakout_confirmed and pullback_confirmation:
      score += 10
  elif downward_breakout_confirmed and pullback_confirmation:
      score -= 10
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 6.3 孤岛反转(Island Reversal)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 确认顶部孤岛反转：-45分
  - 确认底部孤岛反转：+45分
  - 孤岛持续天数：每增加1天额外±5分（最多15分）
  - 跳空幅度：幅度越大额外±10分
  - 成交量配合：额外±10分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 孤岛反转确认
  if bottom_island_reversal_confirmed:
      score += 45
  elif top_island_reversal_confirmed:
      score -= 45
      
  # 孤岛持续天数
  duration_score = min(15, island_duration * 5)  # 最多±15分
  if bottom_island_reversal_confirmed:
      score += duration_score
  elif top_island_reversal_confirmed:
      score -= duration_score
      
  # 跳空幅度
  gap_score = min(10, gap_percentage * 2)  # 最多±10分
  if bottom_island_reversal_confirmed:
      score += gap_score
  elif top_island_reversal_confirmed:
      score -= gap_score
      
  # 成交量配合
  if bottom_island_reversal_confirmed and volume_confirmation:
      score += 10
  elif top_island_reversal_confirmed and volume_confirmation:
      score -= 10
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 6.4 背离指标(Divergence)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 确认正背离（价格创新低但指标未创新低）：+40分
  - 确认负背离（价格创新高但指标未创新高）：-40分
  - 背离幅度：幅度越大额外±15分
  - 多指标背离确认：每个额外确认指标±10分（最多20分）
  - 重复背离确认：额外±15分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 背离确认
  if bullish_divergence_confirmed:
      score += 40
  elif bearish_divergence_confirmed:
      score -= 40
      
  # 背离幅度
  divergence_magnitude_score = min(15, divergence_percentage * 3)  # 最多±15分
  if bullish_divergence_confirmed:
      score += divergence_magnitude_score
  elif bearish_divergence_confirmed:
      score -= divergence_magnitude_score
      
  # 多指标背离确认
  multi_indicator_score = min(20, num_confirming_indicators * 10)  # 最多±20分
  if bullish_divergence_confirmed:
      score += multi_indicator_score
  elif bearish_divergence_confirmed:
      score -= multi_indicator_score
      
  # 重复背离确认
  if repeated_bullish_divergence:
      score += 15
  elif repeated_bearish_divergence:
      score -= 15
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

## 7. 自定义ZXM系统指标打分机制

### 7.1 吸筹洗盘指标(ZXM Absorb)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 确认吸筹行为：+35分
  - 确认出货行为：-35分
  - 吸筹强度：强度越大额外+15分
  - 出货强度：强度越大额外-15分
  - 持续时间：每增加5个周期额外±5分（最多15分）
  - 成交量配合：额外±10分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 吸筹/出货确认
  if absorption_confirmed:
      score += 35
  elif distribution_confirmed:
      score -= 35
      
  # 吸筹/出货强度
  intensity_score = min(15, intensity_level * 5)  # 最多±15分
  if absorption_confirmed:
      score += intensity_score
  elif distribution_confirmed:
      score -= intensity_score
      
  # 持续时间
  duration_periods = pattern_duration / 5
  duration_score = min(15, duration_periods * 5)  # 最多±15分
  if absorption_confirmed:
      score += duration_score
  elif distribution_confirmed:
      score -= duration_score
      
  # 成交量配合
  if (absorption_confirmed and absorption_volume_pattern) or 
     (distribution_confirmed and distribution_volume_pattern):
      score += 10
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 7.2 洗盘指标(ZXM Washplate)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 确认洗盘行为：+30分
  - 洗盘强度：强度越大额外+20分
  - 洗盘后上涨确认：额外+25分
  - 洗盘持续时间：每增加2个周期额外+5分（最多15分）
  - 回踩力度适中：额外+10分

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 洗盘确认
  if washplate_confirmed:
      score += 30
      
  # 洗盘强度
  intensity_score = min(20, washplate_intensity * 5)  # 最多+20分
  if washplate_confirmed:
      score += intensity_score
      
  # 洗盘后上涨确认
  if washplate_followed_by_rise:
      score += 25
      
  # 持续时间
  duration_periods = washplate_duration / 2
  duration_score = min(15, duration_periods * 5)  # 最多+15分
  if washplate_confirmed:
      score += duration_score
      
  # 回踩力度
  if moderate_pullback:
      score += 10
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

### 7.3 多周期共振(Multi-Period Resonance)

- **基础评分规则**：
  - 基础分：50分（中性）
  - 多周期看涨共振：+10分 × 共振周期数（最多40分）
  - 多周期看跌共振：-10分 × 共振周期数（最多40分）
  - 重要周期共振（如日、周、月）：额外±15分
  - 共振持续时间：每持续2个周期额外±5分（最多20分）

- **详细打分机制**：
  ```
  score = 50  # 基础分
  
  # 多周期共振
  bullish_resonance_score = min(40, num_bullish_periods * 10)
  bearish_resonance_score = min(40, num_bearish_periods * 10)
  
  # 净共振得分
  net_resonance = bullish_resonance_score - bearish_resonance_score
  score += net_resonance
  
  # 重要周期共振
  if important_periods_resonance > 0:  # 看涨
      score += min(15, important_periods_resonance * 5)
  elif important_periods_resonance < 0:  # 看跌
      score -= min(15, abs(important_periods_resonance) * 5)
      
  # 共振持续时间
  duration_score = min(20, (resonance_duration / 2) * 5)  # 最多±20分
  if net_resonance > 0:
      score += duration_score
  elif net_resonance < 0:
      score -= duration_score
      
  # 限制得分范围
  score = max(0, min(100, score))
  ```

## 8. 综合信号打分

### 8.1 多指标组合打分

在实际应用中，可以将多个指标的打分进行加权组合，形成更全面的交易决策支持：

```python
def calculate_combined_score(indicator_scores, weights=None):
    """
    计算多指标组合得分
    
    Args:
        indicator_scores: 各指标得分字典 {指标名: 得分}
        weights: 各指标权重字典 {指标名: 权重}，如未提供则平均权重
        
    Returns:
        float: 综合得分 (0-100)
    """
    if not indicator_scores:
        return 50  # 默认中性
        
    if weights is None:
        # 平均权重
        weights = {name: 1.0 / len(indicator_scores) for name in indicator_scores}
    else:
        # 标准化权重，确保权重和为1
        weight_sum = sum(weights.values())
        weights = {name: weight / weight_sum for name, weight in weights.items()}
    
    # 计算加权得分
    combined_score = 0
    for name, score in indicator_scores.items():
        if name in weights:
            combined_score += score * weights[name]
    
    return combined_score
```

### 8.2 信号过滤机制

为了提高信号质量，系统引入多层信号过滤机制：

#### 8.2.1 信号强度过滤
```python
def filter_signals_by_strength(signals, min_score=60, min_confidence=70):
    """
    根据信号强度过滤信号
    """
    filtered_signals = signals[
        (signals['score'] >= min_score) & 
        (signals['confidence'] >= min_confidence)
    ]
    return filtered_signals

def apply_signal_cooling_period(signals, cooling_hours=24):
    """
    应用信号冷却期，避免过度交易
    """
    # 确保同一股票在冷却期内不重复发出同类信号
    last_signal_time = {}
    filtered_signals = []
    
    for _, signal in signals.iterrows():
        key = f"{signal['symbol']}_{signal['signal_type']}"
        current_time = signal['timestamp']
        
        if key not in last_signal_time:
            last_signal_time[key] = current_time
            filtered_signals.append(signal)
        else:
            time_diff = (current_time - last_signal_time[key]).total_seconds() / 3600
            if time_diff >= cooling_hours:
                last_signal_time[key] = current_time
                filtered_signals.append(signal)
    
    return pd.DataFrame(filtered_signals)
```

#### 8.2.2 市场环境过滤
```python
def filter_signals_by_market_environment(signals, market_env):
    """
    根据市场环境过滤信号
    """
    if market_env == 'bear_market':
        # 熊市中更严格的买入信号过滤
        buy_signals = signals[signals['buy_signal'] == True]
        buy_signals = buy_signals[buy_signals['score'] >= 75]  # 提高买入门槛
        
        sell_signals = signals[signals['sell_signal'] == True]
        # 熊市中降低卖出门槛
        sell_signals = sell_signals[sell_signals['score'] <= 40]
        
    elif market_env == 'bull_market':
        # 牛市中放宽买入信号过滤
        buy_signals = signals[signals['buy_signal'] == True]
        buy_signals = buy_signals[buy_signals['score'] >= 55]
        
        sell_signals = signals[signals['sell_signal'] == True]
        # 牛市中提高卖出门槛
        sell_signals = sell_signals[sell_signals['score'] <= 30]
        
    else:  # sideways_market or breakout_market
        # 震荡市中平衡过滤
        buy_signals = signals[signals['buy_signal'] == True]
        buy_signals = buy_signals[buy_signals['score'] >= 65]
        
        sell_signals = signals[signals['sell_signal'] == True]
        sell_signals = sell_signals[sell_signals['score'] <= 35]
    
    return pd.concat([buy_signals, sell_signals])
```

### 8.3 智能交易建议系统

#### 8.3.1 分级交易策略
```python
def generate_trading_recommendations(signal_data, account_info):
    """
    生成智能交易建议
    """
    recommendations = []
    
    for _, signal in signal_data.iterrows():
        recommendation = {
            'symbol': signal['symbol'],
            'action': 'buy' if signal['buy_signal'] else 'sell',
            'urgency': calculate_urgency_level(signal['score'], signal['confidence']),
            'position_size': signal['position_size'],
            'stop_loss': signal['stop_loss'],
            'take_profit': calculate_take_profit(signal),
            'holding_period': estimate_holding_period(signal),
            'risk_reward_ratio': calculate_risk_reward_ratio(signal),
            'entry_strategy': determine_entry_strategy(signal),
            'exit_strategy': determine_exit_strategy(signal)
        }
        recommendations.append(recommendation)
    
    return recommendations

def calculate_urgency_level(score, confidence):
    """
    计算交易紧急程度
    """
    combined_strength = (score + confidence) / 2
    
    if combined_strength >= 85:
        return 'immediate'  # 立即执行
    elif combined_strength >= 70:
        return 'high'       # 高优先级
    elif combined_strength >= 60:
        return 'medium'     # 中等优先级
    else:
        return 'low'        # 低优先级

def determine_entry_strategy(signal):
    """
    确定入场策略
    """
    if signal['score'] >= 80:
        return 'market_order'  # 市价单立即入场
    elif signal['score'] >= 65:
        return 'limit_order_aggressive'  # 激进限价单
    else:
        return 'limit_order_conservative'  # 保守限价单

def calculate_take_profit(signal):
    """
    计算止盈位
    """
    current_price = signal['current_price']
    atr = signal['atr']
    
    if signal['buy_signal']:
        # 根据信号强度调整止盈倍数
        if signal['score'] >= 80:
            profit_multiplier = 3.0  # 强信号，更大止盈空间
        elif signal['score'] >= 65:
            profit_multiplier = 2.5
        else:
            profit_multiplier = 2.0
        
        take_profit = current_price + (atr * profit_multiplier)
    else:
        # 卖出信号的止盈计算
        if signal['score'] <= 20:
            profit_multiplier = 3.0
        elif signal['score'] <= 35:
            profit_multiplier = 2.5
        else:
            profit_multiplier = 2.0
        
        take_profit = current_price - (atr * profit_multiplier)
    
    return take_profit
```

#### 8.3.2 风险管理建议
```python
def generate_risk_management_advice(portfolio_data, market_conditions):
    """
    生成风险管理建议
    """
    advice = {
        'portfolio_risk_level': assess_portfolio_risk(portfolio_data),
        'position_sizing_advice': get_position_sizing_advice(market_conditions),
        'diversification_suggestions': analyze_diversification(portfolio_data),
        'hedging_recommendations': suggest_hedging_strategies(portfolio_data, market_conditions),
        'cash_allocation': recommend_cash_allocation(market_conditions)
    }
    
    return advice

def assess_portfolio_risk(portfolio_data):
    """
    评估投资组合风险水平
    """
    # 计算投资组合的整体风险指标
    total_exposure = sum(position['value'] for position in portfolio_data)
    high_risk_exposure = sum(
        position['value'] for position in portfolio_data 
        if position['risk_level'] == 'high'
    )
    
    risk_ratio = high_risk_exposure / total_exposure if total_exposure > 0 else 0
    
    if risk_ratio > 0.4:
        return 'high'
    elif risk_ratio > 0.2:
        return 'medium'
    else:
        return 'low'

def recommend_cash_allocation(market_conditions):
    """
    推荐现金配置比例
    """
    if market_conditions['environment'] == 'bear_market':
        return 0.4  # 熊市保持40%现金
    elif market_conditions['environment'] == 'bull_market':
        return 0.1  # 牛市保持10%现金
    elif market_conditions['volatility'] == 'high':
        return 0.3  # 高波动时保持30%现金
    else:
        return 0.2  # 正常情况保持20%现金
```

## 9. 实施建议

为了在系统中实现统一的指标打分机制，建议按照以下步骤进行：

1. **指标基类增强**：在`BaseIndicator`类中添加标准化的信号评分方法

2. **分阶段实现**：
   - 第一阶段：实现趋势类指标和常用震荡指标的打分
   - 第二阶段：实现成交量和波动率指标的打分
   - 第三阶段：实现模式识别和特殊指标的打分

3. **测试验证**：
   - 使用历史数据测试每个指标的打分准确性
   - 验证不同指标组合的综合打分效果
   - 回测验证打分系统的实际交易效果

4. **用户界面集成**：
   - 在系统界面中添加信号强度可视化
   - 提供信号置信度和建议操作的展示
   - 支持用户自定义指标权重

5. **持续优化**：
   - 收集用户反馈，调整打分权重
   - 根据市场表现，定期校准评分标准
   - 考虑引入机器学习方法优化权重分配

## 10. 结论

统一的技术指标打分机制为交易决策提供了量化依据，可以有效减少主观判断带来的偏差。该机制具有以下优势：

1. **标准化输出**：所有指标使用0-100的统一评分标准
2. **多维度评估**：综合考虑信号类型、强度、持续性等因素
3. **可组合性**：支持多指标组合决策，可根据需要调整权重
4. **可解释性**：每个得分都有明确的计算依据，易于理解和调整
5. **系统集成**：与现有指标计算框架无缝集成，便于实施

通过在指标类中实现这些打分机制，系统将能够为用户提供更加客观、量化的技术分析结果，帮助用户做出更加理性的交易决策。

## 10. 实战应用指南

### 10.1 系统配置示例

#### 10.1.1 基础配置文件
```yaml
# config/indicator_scoring.yaml
indicator_scoring:
  # 市场环境权重配置
  market_environment_weights:
    bull_market:
      trend_indicators: 0.45
      oscillator_indicators: 0.25
      volume_indicators: 0.20
      volatility_indicators: 0.10
    bear_market:
      trend_indicators: 0.30
      oscillator_indicators: 0.40
      volume_indicators: 0.15
      volatility_indicators: 0.15
    sideways_market:
      trend_indicators: 0.20
      oscillator_indicators: 0.50
      volume_indicators: 0.20
      volatility_indicators: 0.10
    breakout_market:
      trend_indicators: 0.35
      oscillator_indicators: 0.20
      volume_indicators: 0.30
      volatility_indicators: 0.15

  # 信号过滤配置
  signal_filters:
    min_score: 60
    min_confidence: 70
    cooling_period_hours: 24
    max_signals_per_day: 10

  # 风险管理配置
  risk_management:
    max_position_size: 0.10  # 单笔最大10%仓位
    default_risk_per_trade: 0.02  # 默认每笔交易风险2%
    atr_stop_loss_multiplier: 2.0
    profit_target_multiplier: 2.5

  # 动态阈值配置
  dynamic_thresholds:
    rsi:
      high_volatility: [25, 75]
      normal_volatility: [30, 70]
      low_volatility: [35, 65]
    
    macd:
      energy_threshold: 0.5
      divergence_strength_threshold: 0.5
```

#### 10.1.2 使用代码示例
```python
from indicators.enhanced_scoring import EnhancedScoringSystem
from config.config_manager import get_config

# 初始化增强打分系统
scoring_system = EnhancedScoringSystem()

# 加载配置
config = get_config('indicator_scoring')

# 设置市场环境
market_env = scoring_system.detect_market_environment(price_data, volume_data)
scoring_system.set_market_environment(market_env)

# 计算多指标综合得分
indicators_data = {
    'macd': macd_data,
    'rsi': rsi_data,
    'kdj': kdj_data,
    'obv': obv_data,
    'boll': boll_data
}

# 生成综合信号
comprehensive_signals = scoring_system.generate_comprehensive_signals(
    indicators_data, 
    price_data, 
    volume_data
)

# 应用信号过滤
filtered_signals = scoring_system.apply_signal_filters(
    comprehensive_signals,
    config['signal_filters']
)

# 生成交易建议
trading_recommendations = scoring_system.generate_trading_recommendations(
    filtered_signals,
    account_info={'balance': 100000, 'positions': current_positions}
)

# 输出结果
for recommendation in trading_recommendations:
    print(f"股票: {recommendation['symbol']}")
    print(f"操作: {recommendation['action']}")
    print(f"紧急程度: {recommendation['urgency']}")
    print(f"建议仓位: {recommendation['position_size']:.2%}")
    print(f"止损位: {recommendation['stop_loss']:.2f}")
    print(f"止盈位: {recommendation['take_profit']:.2f}")
    print("---")
```

### 10.2 分级交易策略

#### 10.2.1 保守型策略
```python
CONSERVATIVE_CONFIG = {
    'signal_filters': {
        'min_score': 75,
        'min_confidence': 80,
        'cooling_period_hours': 48
    },
    'risk_management': {
        'max_position_size': 0.05,
        'risk_per_trade': 0.01,
        'atr_multiplier': 1.5
    },
    'market_environment_adjustment': {
        'bear_market_score_boost': 10,  # 熊市中提高买入门槛
        'bull_market_score_reduction': -5  # 牛市中适度降低门槛
    }
}
```

#### 10.2.2 激进型策略
```python
AGGRESSIVE_CONFIG = {
    'signal_filters': {
        'min_score': 55,
        'min_confidence': 60,
        'cooling_period_hours': 12
    },
    'risk_management': {
        'max_position_size': 0.15,
        'risk_per_trade': 0.03,
        'atr_multiplier': 2.5
    },
    'leverage_settings': {
        'max_leverage': 2.0,
        'leverage_threshold_score': 80
    }
}
```

### 10.3 性能监控与优化

#### 10.3.1 交易记录跟踪
```python
class TradingPerformanceTracker:
    def __init__(self):
        self.trades = []
        self.performance_metrics = {}
    
    def record_trade(self, trade_data):
        """记录交易数据"""
        trade_record = {
            'timestamp': trade_data['timestamp'],
            'symbol': trade_data['symbol'],
            'action': trade_data['action'],
            'entry_price': trade_data['entry_price'],
            'exit_price': trade_data.get('exit_price'),
            'position_size': trade_data['position_size'],
            'signal_score': trade_data['signal_score'],
            'signal_confidence': trade_data['signal_confidence'],
            'market_environment': trade_data['market_environment'],
            'profit_loss': trade_data.get('profit_loss'),
            'holding_period': trade_data.get('holding_period')
        }
        self.trades.append(trade_record)
    
    def calculate_performance_metrics(self):
        """计算性能指标"""
        if not self.trades:
            return {}
        
        completed_trades = [t for t in self.trades if t['exit_price'] is not None]
        
        if not completed_trades:
            return {}
        
        total_trades = len(completed_trades)
        winning_trades = [t for t in completed_trades if t['profit_loss'] > 0]
        losing_trades = [t for t in completed_trades if t['profit_loss'] < 0]
        
        win_rate = len(winning_trades) / total_trades
        avg_win = sum(t['profit_loss'] for t in winning_trades) / len(winning_trades) if winning_trades else 0
        avg_loss = sum(t['profit_loss'] for t in losing_trades) / len(losing_trades) if losing_trades else 0
        
        profit_factor = abs(avg_win / avg_loss) if avg_loss != 0 else float('inf')
        
        # 按信号强度分析
        high_score_trades = [t for t in completed_trades if t['signal_score'] >= 80]
        high_score_win_rate = len([t for t in high_score_trades if t['profit_loss'] > 0]) / len(high_score_trades) if high_score_trades else 0
        
        return {
            'total_trades': total_trades,
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'high_score_win_rate': high_score_win_rate,
            'avg_holding_period': sum(t['holding_period'] for t in completed_trades) / total_trades
        }
    
    def generate_optimization_suggestions(self):
        """生成优化建议"""
        metrics = self.calculate_performance_metrics()
        suggestions = []
        
        if metrics.get('win_rate', 0) < 0.5:
            suggestions.append("胜率偏低，建议提高信号过滤门槛")
        
        if metrics.get('profit_factor', 0) < 1.5:
            suggestions.append("盈亏比不理想，建议调整止盈止损比例")
        
        if metrics.get('high_score_win_rate', 0) > metrics.get('win_rate', 0) + 0.1:
            suggestions.append("高分信号表现更好，建议提高最低信号分数要求")
        
        return suggestions
```

#### 10.3.2 自动优化建议
```python
def generate_auto_optimization_advice(performance_data, market_conditions):
    """
    基于历史表现自动生成优化建议
    """
    advice = {
        'parameter_adjustments': {},
        'strategy_modifications': [],
        'risk_management_updates': {}
    }
    
    # 分析不同市场环境下的表现
    for env in ['bull_market', 'bear_market', 'sideways_market']:
        env_trades = [t for t in performance_data if t['market_environment'] == env]
        if env_trades:
            env_win_rate = len([t for t in env_trades if t['profit_loss'] > 0]) / len(env_trades)
            
            if env_win_rate < 0.4:
                advice['strategy_modifications'].append(
                    f"在{env}环境下表现不佳，建议调整该环境下的权重配置"
                )
    
    # 分析信号强度与成功率的关系
    score_ranges = [(60, 70), (70, 80), (80, 90), (90, 100)]
    for min_score, max_score in score_ranges:
        range_trades = [
            t for t in performance_data 
            if min_score <= t['signal_score'] < max_score
        ]
        if range_trades:
            range_win_rate = len([t for t in range_trades if t['profit_loss'] > 0]) / len(range_trades)
            
            if range_win_rate > 0.6:
                advice['parameter_adjustments'][f'score_range_{min_score}_{max_score}'] = {
                    'recommendation': 'increase_weight',
                    'reason': f'该分数区间胜率达到{range_win_rate:.2%}'
                }
    
    return advice
```

### 10.4 部署与维护

#### 10.4.1 系统部署清单
```markdown
## 部署前检查清单

### 环境准备
- [ ] Python 3.8+ 环境
- [ ] 必要的依赖包安装 (pandas, numpy, talib, etc.)
- [ ] 数据库连接配置
- [ ] 日志目录权限设置

### 配置文件
- [ ] indicator_scoring.yaml 配置正确
- [ ] 数据库连接参数设置
- [ ] 风险管理参数符合要求
- [ ] 市场环境权重配置合理

### 数据准备
- [ ] 历史价格数据完整
- [ ] 成交量数据可用
- [ ] 技术指标计算正常
- [ ] 数据更新机制运行正常

### 测试验证
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 回测验证完成
- [ ] 性能测试达标

### 监控设置
- [ ] 日志监控配置
- [ ] 性能指标监控
- [ ] 异常告警设置
- [ ] 数据质量监控
```

#### 10.4.2 维护监控方案
```python
# 系统健康检查
def system_health_check():
    """系统健康状态检查"""
    health_status = {
        'data_freshness': check_data_freshness(),
        'indicator_calculation': test_indicator_calculations(),
        'signal_generation': test_signal_generation(),
        'performance_tracking': check_performance_tracking(),
        'error_rate': calculate_error_rate(),
        'response_time': measure_response_time()
    }
    
    overall_health = 'healthy' if all(
        status == 'ok' for status in health_status.values()
    ) else 'warning'
    
    return {
        'overall_status': overall_health,
        'details': health_status,
        'timestamp': datetime.now(),
        'recommendations': generate_maintenance_recommendations(health_status)
    }

# 定期维护任务
def scheduled_maintenance():
    """定期维护任务"""
    tasks = [
        'clean_old_logs',
        'update_market_environment_detection',
        'recalibrate_dynamic_thresholds',
        'optimize_signal_filters',
        'backup_performance_data',
        'update_risk_parameters'
    ]
    
    for task in tasks:
        try:
            execute_maintenance_task(task)
            log_maintenance_success(task)
        except Exception as e:
            log_maintenance_error(task, e)
            send_maintenance_alert(task, e)
```

通过以上完善的技术指标打分机制，系统能够：

1. **智能适应市场环境**：根据不同市场状态动态调整评分权重
2. **多维度信号评估**：综合考虑信号强度、置信度、风险等因素
3. **精准风险控制**：提供动态止损、仓位管理、信号过滤等功能
4. **实战指导价值**：生成具体的交易建议和风险管理方案
5. **持续优化能力**：通过性能监控和自动优化不断改进系统表现

这套机制将原有的静态打分系统升级为智能化的动态交易决策支持系统，为交易者提供更加专业和可靠的技术分析工具。