# 可配置选股系统设计方案

## 一、系统概述

### 1.1 设计目标

设计一个灵活可配置的选股系统，使用户能够通过简洁的配置文件组合不同技术指标形成选股策略，无需编程即可实现复杂的选股逻辑。系统将无缝集成到现有项目架构中，提供高效且易用的选股体验。

### 1.2 系统定位

本系统是股票分析平台的核心组件之一，专注于技术指标驱动的选股功能。它连接上游的数据获取模块和下游的结果展示模块，为用户提供从指标计算到选股结果生成的完整服务链路。

### 1.3 系统架构图

```
+------------------+    +------------------+    +------------------+
|                  |    |                  |    |                  |
|  数据获取与处理   |    |  指标计算引擎    |    |  策略执行引擎    |
|                  |    |                  |    |                  |
+------------------+    +------------------+    +------------------+
         |                       |                       |
         v                       v                       v
+------------------+    +------------------+    +------------------+
|                  |    |                  |    |                  |
|  数据存储与缓存   |    |  配置管理模块    |    |  结果输出模块    |
|                  |    |                  |    |                  |
+------------------+    +------------------+    +------------------+
```

### 1.4 设计原则

1. **简单易用**：配置文件结构简洁明了，易于理解和修改
2. **高度灵活**：支持多种指标组合和灵活的条件设置
3. **可扩展性**：易于添加新指标和新功能
4. **性能优先**：优化大规模数据处理性能
5. **错误容忍**：提供完善的错误处理和异常恢复机制
6. **模块化设计**：遵循项目架构规范，各模块职责明确

## 二、核心模块设计

### 2.1 指标引擎模块

#### 2.1.1 模块职责
指标引擎模块负责所有技术指标的计算和信号生成，是系统的核心计算组件。本模块将实现各类技术指标，并提供统一的接口进行调用。

#### 2.1.2 指标抽象设计
1. **指标基类**
   ```python
   # indicators/base_indicator.py
   from abc import ABC, abstractmethod
   import pandas as pd
   from typing import Dict, Any
   
   class BaseIndicator(ABC):
       """指标基类，所有具体指标实现必须继承此类"""
       
       @abstractmethod
       def calculate(self, data: pd.DataFrame, **params) -> pd.DataFrame:
           """
           计算指标值
           
           Args:
               data: 包含OHLCV数据的DataFrame
               **params: 指标参数
               
           Returns:
               计算结果DataFrame
           """
           pass
           
       @abstractmethod
       def generate_signals(self, indicator_values: pd.DataFrame, **params) -> pd.DataFrame:
           """
           生成指标信号
           
           Args:
               indicator_values: 指标计算结果
               **params: 信号生成参数
               
           Returns:
               信号结果DataFrame
           """
           pass
       
       def get_default_params(self) -> Dict[str, Any]:
           """获取指标的默认参数"""
           return {}
           
       def validate_params(self, params: Dict[str, Any]) -> Dict[str, Any]:
           """验证并返回有效的参数"""
           return params
   ```

2. **指标工厂**
   ```python
   # indicators/indicator_factory.py
   from typing import Dict, Type
   from .base_indicator import BaseIndicator
   
   class IndicatorFactory:
       """指标工厂类，负责创建和管理指标实例"""
       
       _indicators = {}  # 注册的指标字典
       
       @classmethod
       def register(cls, indicator_id: str, indicator_class: Type[BaseIndicator]) -> None:
           """注册指标类"""
           cls._indicators[indicator_id] = indicator_class
           
       @classmethod
       def create(cls, indicator_id: str, **kwargs) -> BaseIndicator:
           """创建指标实例"""
           if indicator_id not in cls._indicators:
               raise ValueError(f"未知的指标ID: {indicator_id}")
           return cls._indicators[indicator_id](**kwargs)
           
       @classmethod
       def list_indicators(cls) -> Dict[str, Type[BaseIndicator]]:
           """获取所有已注册的指标"""
           return cls._indicators.copy()
   ```

#### 2.1.3 指标分类与实现
1. **趋势类指标**
   ```python
   # indicators/trend/ma_cross.py
   import pandas as pd
   from typing import Dict, Any
   from indicators.base_indicator import BaseIndicator
   
   class MACross(BaseIndicator):
       """均线交叉指标"""
       
       def get_default_params(self) -> Dict[str, Any]:
           """获取默认参数"""
           return {
               'fast_period': 5,
               'slow_period': 20
           }
           
       def validate_params(self, params: Dict[str, Any]) -> Dict[str, Any]:
           """验证参数"""
           validated = params.copy()
           
           # 确保必要参数存在
           if 'fast_period' not in validated:
               validated['fast_period'] = self.get_default_params()['fast_period']
           if 'slow_period' not in validated:
               validated['slow_period'] = self.get_default_params()['slow_period']
               
           # 确保快线周期小于慢线周期
           if validated['fast_period'] >= validated['slow_period']:
               raise ValueError("快线周期必须小于慢线周期")
               
           # 确保周期为正整数
           if validated['fast_period'] <= 0 or not isinstance(validated['fast_period'], int):
               raise ValueError("快线周期必须为正整数")
           if validated['slow_period'] <= 0 or not isinstance(validated['slow_period'], int):
               raise ValueError("慢线周期必须为正整数")
               
           return validated
       
       def calculate(self, data: pd.DataFrame, **params) -> pd.DataFrame:
           """计算快慢均线"""
           # 验证参数
           valid_params = self.validate_params(params)
           fast_period = valid_params['fast_period']
           slow_period = valid_params['slow_period']
           
           # 确保数据包含收盘价
           if 'close' not in data.columns:
               raise ValueError("数据必须包含收盘价(close)列")
               
           # 计算指标
           result = data.copy()
           result['fast_ma'] = data['close'].rolling(fast_period).mean()
           result['slow_ma'] = data['close'].rolling(slow_period).mean()
           
           return result
       
       def generate_signals(self, indicator_values: pd.DataFrame, **params) -> pd.DataFrame:
           """生成金叉死叉信号"""
           # 确保指标数据包含必要的列
           required_columns = ['fast_ma', 'slow_ma']
           for col in required_columns:
               if col not in indicator_values.columns:
                   raise ValueError(f"指标数据缺少必要的列: {col}")
           
           # 初始化信号DataFrame
           signals = pd.DataFrame(index=indicator_values.index)
           
           # 金叉信号：快线从下方穿越慢线
           signals['golden_cross'] = (indicator_values['fast_ma'] > indicator_values['slow_ma']) & \
                                     (indicator_values['fast_ma'].shift(1) <= indicator_values['slow_ma'].shift(1))
           
           # 死叉信号：快线从上方穿越慢线
           signals['dead_cross'] = (indicator_values['fast_ma'] < indicator_values['slow_ma']) & \
                                   (indicator_values['fast_ma'].shift(1) >= indicator_values['slow_ma'].shift(1))
           
           # 多头排列信号：快线在上方
           signals['bull_trend'] = indicator_values['fast_ma'] > indicator_values['slow_ma']
           
           # 空头排列信号：快线在下方
           signals['bear_trend'] = indicator_values['fast_ma'] < indicator_values['slow_ma']
           
           return signals
   ```

#### 2.1.4 支持的指标类型

根据《股票技术分析指标大全》，系统将支持以下几类指标：

1. **趋势类指标**：MA、EMA、WMA、MACD、SAR、DMI、BIAS、BOLL等
2. **震荡类指标**：RSI、KDJ、WR、CCI、MTM、ROC、StochRSI等
3. **量能类指标**：VOL、OBV、VOSC、MFI、VR、PVT、量比等
4. **压力支撑类指标**：斐波那契回调、江恩理论、支撑压力线等
5. **周期类指标**：时间周期分析、日内波动率、江恩时间周期等
6. **反转类指标**：钻石底/头肩底、双底/双顶、岛型反转等
7. **K线形态指标**：单日K线形态、组合K线形态、复合形态等
8. **综合指标**：指标交叉信号、多周期共振、量价背离等
9. **特色指标**：ZXM买点分类、吸筹形态、洗盘形态等

#### 2.1.5 信号类型定义

系统将支持以下信号类型：

1. **交叉信号**：金叉、死叉等线与线之间的交叉
2. **阈值信号**：超买、超卖等指标值超过特定阈值
3. **形态信号**：特定K线形态或指标形态
4. **趋势信号**：趋势开始、结束、加速、减速等
5. **背离信号**：指标与价格之间的背离
6. **组合信号**：多个信号组合形成的复合信号

### 2.2 策略管理模块

#### 2.2.1 模块职责
策略管理模块负责策略的定义、存储、加载和版本控制，为用户提供创建和管理选股策略的功能。

#### 2.2.2 策略配置格式

系统使用JSON格式进行策略配置，基本结构如下：

```json
{
  "strategy": {
    "id": "STRATEGY_001",
    "name": "趋势反转策略",
    "description": "寻找短期反转并有长期趋势支撑的股票",
    "version": "1.0",
    "author": "system",
    "create_time": "2023-06-01 10:00:00",
    "update_time": "2023-06-02 15:30:00",
    "conditions": [
      {
        "indicator_id": "MA_CROSS",
        "period": "DAILY",
        "parameters": {
          "fast_period": 5,
          "slow_period": 20
        },
        "signal_type": "CROSS_OVER"
      },
      {
        "indicator_id": "KDJ_GOLDEN_CROSS",
        "period": "WEEKLY",
        "parameters": {
          "k_period": 9,
          "d_period": 3
        },
        "signal_type": "CROSS_OVER"
      },
      {
        "logic": "AND"
      }
    ],
    "filters": {
      "market": ["主板", "科创板", "创业板"],
      "industry": [],
      "market_cap": {
        "min": 50,
        "max": 2000
      },
      "price": {
        "min": 5,
        "max": 100
      }
    },
    "sort": [
      {
        "field": "signal_strength",
        "direction": "DESC"
      },
      {
        "field": "market_cap",
        "direction": "ASC"
      }
    ]
  }
}
```

#### 2.2.3 策略管理器设计

```python
# strategy/strategy_manager.py
import uuid
import copy
from datetime import datetime
from typing import Dict, List, Optional, Any

class StrategyManager:
    """策略管理器，负责策略的创建、保存、加载和版本控制"""
    
    def __init__(self, db_manager):
        self.db_manager = db_manager
        
    def create_strategy(self, strategy_config: Dict[str, Any]) -> str:
        """创建新策略"""
        # 验证策略配置
        self._validate_strategy_config(strategy_config)
        
        # 生成策略ID
        if "id" not in strategy_config["strategy"]:
            strategy_config["strategy"]["id"] = self._generate_strategy_id()
            
        # 设置创建和更新时间
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        strategy_config["strategy"]["create_time"] = now
        strategy_config["strategy"]["update_time"] = now
        
        # 保存策略
        self.db_manager.save_strategy(strategy_config)
        return strategy_config["strategy"]["id"]
        
    def update_strategy(self, strategy_id: str, strategy_config: Dict[str, Any]) -> str:
        """更新现有策略"""
        # 获取原策略
        original_strategy = self.get_strategy(strategy_id)
        if not original_strategy:
            raise ValueError(f"策略 {strategy_id} 不存在")
            
        # 合并配置
        merged_config = self._merge_strategy_configs(original_strategy, strategy_config)
        
        # 更新时间
        merged_config["strategy"]["update_time"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # 保存策略
        self.db_manager.save_strategy(merged_config)
        return strategy_id
        
    def get_strategy(self, strategy_id: str) -> Optional[Dict[str, Any]]:
        """获取策略定义"""
        return self.db_manager.get_strategy(strategy_id)
        
    def list_strategies(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """列出所有策略"""
        return self.db_manager.list_strategies(filters)
        
    def delete_strategy(self, strategy_id: str) -> bool:
        """删除策略"""
        return self.db_manager.delete_strategy(strategy_id)
        
    def _validate_strategy_config(self, strategy_config: Dict[str, Any]) -> bool:
        """验证策略配置"""
        # 验证必要字段
        required_fields = ["name", "conditions"]
        for field in required_fields:
            if field not in strategy_config["strategy"]:
                raise ValueError(f"策略配置缺少必要字段 {field}")
                
        # 验证条件配置
        for condition in strategy_config["strategy"]["conditions"]:
            if "logic" in condition:
                if condition["logic"] not in ["AND", "OR", "NOT"]:
                    raise ValueError(f"不支持的逻辑运算符: {condition['logic']}")
            else:
                if "indicator_id" not in condition:
                    raise ValueError("条件缺少 indicator_id 字段")
                if "period" not in condition:
                    raise ValueError("条件缺少 period 字段")
                    
        return True
        
    def _generate_strategy_id(self) -> str:
        """生成唯一策略ID"""
        return f"STRATEGY_{uuid.uuid4().hex[:8].upper()}"
        
    def _merge_strategy_configs(self, original: Dict[str, Any], updates: Dict[str, Any]) -> Dict[str, Any]:
        """合并策略配置"""
        merged = copy.deepcopy(original)
        for key, value in updates["strategy"].items():
            if key != "id" and key != "create_time":
                merged["strategy"][key] = value
        return merged
```

#### 2.2.4 策略解析器设计

```python
# strategy/strategy_parser.py
from typing import Dict, List, Any
import pandas as pd
from indicators.indicator_factory import IndicatorFactory

class StrategyParser:
    """策略解析器，负责解析策略配置并构建策略执行计划"""
    
    def __init__(self, indicator_factory: IndicatorFactory):
        self.indicator_factory = indicator_factory
        
    def parse_strategy(self, strategy_config: Dict[str, Any]) -> Dict[str, Any]:
        """解析策略配置并返回执行计划"""
        strategy = strategy_config["strategy"]
        
        # 解析条件
        conditions = self._parse_conditions(strategy["conditions"])
        
        # 解析过滤器
        filters = self._parse_filters(strategy.get("filters", {}))
        
        # 解析排序
        sort = self._parse_sort(strategy.get("sort", []))
        
        return {
            "strategy_id": strategy["id"],
            "name": strategy["name"],
            "description": strategy.get("description", ""),
            "conditions": conditions,
            "filters": filters,
            "sort": sort
        }
        
    def _parse_conditions(self, conditions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """解析策略条件"""
        parsed_conditions = []
        
        for condition in conditions:
            if "logic" in condition:
                # 逻辑运算符
                parsed_conditions.append({
                    "type": "logic",
                    "value": condition["logic"]
                })
            else:
                # 指标条件
                indicator = self.indicator_factory.create(
                    condition["indicator_id"],
                    **condition.get("parameters", {})
                )
                
                parsed_conditions.append({
                    "type": "indicator",
                    "indicator": indicator,
                    "period": condition["period"],
                    "signal_type": condition.get("signal_type", "DEFAULT")
                })
                
        return parsed_conditions
        
    def _parse_filters(self, filters: Dict[str, Any]) -> Dict[str, Any]:
        """解析过滤条件"""
        parsed_filters = {}
        
        for key, value in filters.items():
            parsed_filters[key] = value
            
        return parsed_filters
        
    def _parse_sort(self, sort: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """解析排序条件"""
        parsed_sort = []
        
        for sort_item in sort:
            parsed_sort.append({
                "field": sort_item["field"],
                "direction": sort_item["direction"]
            })
            
        return parsed_sort
```

### 2.3 数据访问模块

#### 2.3.1 模块职责
数据访问模块负责从ClickHouse数据库获取股票数据，并提供数据缓存和高效查询功能。

#### 2.3.2 数据管理器设计
```python
# db/data_manager.py
import pandas as pd
from typing import Dict, List, Optional, Any
from utils.logger import get_logger
from db.clickhouse_db import get_clickhouse_db

logger = get_logger(__name__)

class DataManager:
    """数据管理器，负责数据的获取和缓存"""
    
    def __init__(self, cache_enabled=True, cache_ttl=3600):
        self.db = get_clickhouse_db()
        self.cache_enabled = cache_enabled
        self.cache_ttl = cache_ttl
        self.cache = {}
        self.cache_timestamp = {}
        
    def get_kline_data(self, stock_code: str, period: str, start_date: str, end_date: str, 
                       fields: Optional[List[str]] = None) -> pd.DataFrame:
        """
        获取K线数据
        
        Args:
            stock_code: 股票代码
            period: 周期(DAILY, WEEKLY, MONTHLY, MIN60, MIN30, MIN15, MIN5)
            start_date: 开始日期
            end_date: 结束日期
            fields: 字段列表，默认为所有字段
            
        Returns:
            K线数据DataFrame
        """
        # 构建缓存键
        cache_key = f"{stock_code}_{period}_{start_date}_{end_date}_{','.join(fields or [])}"
        
        # 检查缓存
        if self.cache_enabled and cache_key in self.cache:
            # 检查缓存是否过期
            import time
            if time.time() - self.cache_timestamp.get(cache_key, 0) < self.cache_ttl:
                logger.debug(f"从缓存获取数据: {cache_key}")
                return self.cache[cache_key]
        
        # 构建查询字段
        if fields is None:
            fields = ['date', 'open', 'high', 'low', 'close', 'volume', 'amount']
        
        # 构建查询SQL
        table_name = self._get_table_name(period)
        field_str = ', '.join(fields)
        sql = f"""
        SELECT {field_str}
        FROM {table_name}
        WHERE stock_code = '{stock_code}'
          AND date >= '{start_date}'
          AND date <= '{end_date}'
        ORDER BY date
        """
        
        # 执行查询
        logger.debug(f"执行SQL查询: {sql}")
        result = self.db.query(sql)
        
        # 更新缓存
        if self.cache_enabled:
            import time
            self.cache[cache_key] = result
            self.cache_timestamp[cache_key] = time.time()
        
        return result
    
    def get_stock_list(self, filters: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        """
        获取股票列表
        
        Args:
            filters: 过滤条件
            
        Returns:
            股票列表DataFrame
        """
        # 构建查询条件
        where_clause = "WHERE 1=1"
        if filters:
            if 'market' in filters and filters['market']:
                markets = "', '".join(filters['market'])
                where_clause += f" AND market IN ('{markets}')"
            if 'industry' in filters and filters['industry']:
                industries = "', '".join(filters['industry'])
                where_clause += f" AND industry IN ('{industries}')"
            if 'market_cap' in filters:
                if 'min' in filters['market_cap']:
                    where_clause += f" AND market_cap >= {filters['market_cap']['min']}"
                if 'max' in filters['market_cap']:
                    where_clause += f" AND market_cap <= {filters['market_cap']['max']}"
        
        # 构建查询SQL
        sql = f"""
        SELECT stock_code, stock_name, market, industry, market_cap
        FROM stock_basic
        {where_clause}
        """
        
        # 执行查询
        logger.debug(f"执行SQL查询: {sql}")
        return self.db.query(sql)
    
    def clear_cache(self):
        """清除所有缓存"""
        self.cache = {}
        self.cache_timestamp = {}
        logger.info("已清除所有数据缓存")
    
    def _get_table_name(self, period: str) -> str:
        """根据周期获取对应的表名"""
        period_map = {
            'DAILY': 'kline_daily',
            'WEEKLY': 'kline_weekly',
            'MONTHLY': 'kline_monthly',
            'MIN60': 'kline_60min',
            'MIN30': 'kline_30min',
            'MIN15': 'kline_15min',
            'MIN5': 'kline_5min'
        }
        
        if period not in period_map:
            raise ValueError(f"不支持的周期: {period}")
            
        return period_map[period]
```