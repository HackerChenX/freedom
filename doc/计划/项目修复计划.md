[模式：计划]

遵命，我们现在进入计划模式。

我将根据《问题诊断报告》和《技术方案思路研讨》中确定的策略，制定一份详尽、具体、原子化的技术实施计划。该计划将作为下一阶段"执行模式"的唯一行动指南。

所有计划内容将被记录在 `doc/计划/项目修复计划.md` 文件中。

### 技术规范

1.  **第一阶段：隔离测试噪音**
    *   **目标**：立即将 `examples` 目录从 `pytest` 的测试范围中排除，以清理测试报告，让我们能够专注于核心的单元和集成测试。
    *   **文件**：在项目根目录下创建 `pytest.ini`。
    *   **内容**：
        ```ini
        [pytest]
        norecursedirs = examples .venv
        ```
    *   **理由**：此操作对应"创新模式"中"隔离并延后处理"的决定，是性价比最高的步骤，能立即使测试环境变得清晰。

2.  **第二阶段：修复核心组件接口**
    *   **目标**：解决 `DataManager` 的接口调用错误，以消除大量依赖此组件的测试失败。
    *   **文件**：`db/data_manager.py`。
    *   **变更**：在 `DataManager` 类中添加一个向后兼容的别名方法 `get_kline_data`。此方法将内部调用现有的 `get_stock_info` 方法，并能灵活处理不同的参数。
    *   **实现细节**：
        ```python
        # 在 DataManager 类中，get_stock_info 方法之后添加
        def get_kline_data(self, stock_code: str, start_date: Optional[str] = None, 
                             end_date: Optional[str] = None, level: str = 'day',
                             **kwargs) -> pd.DataFrame:
            """
            获取K线数据的兼容性接口（别名）。
            内部调用 get_stock_info 并返回其包含的DataFrame。
            """
            logger.warning("方法 get_kline_data 已被弃用，请尽快切换到 get_stock_info。")
            
            # 调用主方法
            stock_info_obj = self.get_stock_info(
                stock_code=stock_code,
                start_date=start_date,
                end_date=end_date,
                level=level
            )
            
            # 返回 StockInfo 对象中的数据 DataFrame
            if stock_info_obj:
                return stock_info_obj.data
            return pd.DataFrame()
        ```
    *   **理由**：采用"添加别名"的推荐方案，风险最低，改动最小，且能立即修复所有相关的测试失败。

3.  **第三阶段：强制稳定指标接口**
    *   **目标**：通过在 `BaseIndicator` 中定义抽象方法，强制所有指标子类遵循统一的接口规范。
    *   **文件**：`indicators/base_indicator.py` (如果存在，否则将创建或定位正确文件)。
    *   **变更**：
        1.  导入 `ABC` 和 `abstractmethod` 从 `abc` 模块。
        2.  让 `BaseIndicator` 继承自 `ABC`。
        3.  将 `_calculate`, `calculate_raw_score`, `get_patterns`, `set_parameters` 方法标记为 `@abstractmethod`。
    *   **理由**：这是"强制接口契约"的核心，从根本上保证了代码库的一致性和可维护性。

4.  **第四阶段：为具体指标实现接口存根**
    *   **目标**：为报告中提到的、不符合新接口规范的指标类添加必要的方法存根（stub），以使其能够被成功实例化。
    *   **文件列表**：`indicators/rsi.py`, `indicators/bias.py`, `indicators/boll.py`。
    *   **通用变更**：为每个文件中的指标类添加缺失的抽象方法实现。
        ```python
        def set_parameters(self, **kwargs):
            # 根据需要设置参数，或直接跳过
            pass

        def _calculate(self, data: pd.DataFrame):
            # 具体的指标计算逻辑
            raise NotImplementedError("Subclasses must implement _calculate.")

        def calculate_raw_score(self, data: pd.DataFrame):
            # 默认的评分逻辑
            return pd.DataFrame(index=data.index)

        def get_patterns(self, data: pd.DataFrame):
            # 默认的形态识别逻辑
            return pd.DataFrame(index=data.index)
        ```
    *   **特定变更**：
        *   对于 `RSI` 和 `BIAS`，如果存在 `calculate` 方法，需重命名为 `_calculate`。
    *   **理由**：这是解决大量 `TypeError` 和 `AttributeError` 的直接手段。

5.  **第五阶段：修复特定测试用例的逻辑错误**
    *   **目标**：修正报告中明确指出的两个测试文件中的逻辑硬伤。
    *   **文件 1**: `tests/unit/test_kdj.py`
        *   **问题**: `KeyError`，由于错误的断言方式。
        *   **修复**: 将直接的字典键访问改为检查 DataFrame 中是否存在特定模式的行。
    *   **文件 2**: `tests/unit/test_indicators.py`
        *   **问题**: `NameError`，在使用 `ema` 变量前未实例化。
        *   **修复**: 在调用 `ema.calculate()` 之前，添加 `ema = EMAIndicator(...)` 的实例化代码。
    *   **理由**：清理已知的、明确的测试逻辑错误，恢复测试用例的有效性。

---
### IMPLEMENTATION CHECKLIST:

1.  在项目根目录创建文件 `pytest.ini`，并写入内容以忽略 `examples` 和 `.venv` 目录。
2.  读取文件 `db/data_manager.py`。
3.  修改 `db/data_manager.py`，在 `DataManager` 类中添加 `get_kline_data` 方法作为 `get_stock_info` 的别名。
4.  搜索 `class BaseIndicator` 找到其定义所在的文件。
5.  读取包含 `BaseIndicator` 的文件。
6.  修改 `BaseIndicator` 的定义，使其继承自 `abc.ABC` 并为 `_calculate`, `calculate_raw_score`, `get_patterns`, `set_parameters` 方法添加 `@abstractmethod` 装饰器。
7.  读取文件 `indicators/rsi.py`。
8.  修改 `indicators/rsi.py` 中的 `RSI` 类，确保它实现了所有四个抽象方法（如果存在 `calculate`，则重命名为 `_calculate`）。
9.  读取文件 `indicators/bias.py`。
10. 修改 `indicators/bias.py` 中的 `BIAS` 类，确保它实现了所有四个抽象方法（如果存在 `calculate`，则重命名为 `_calculate`）。
11. 读取文件 `indicators/boll.py`。
12. 修改 `indicators/boll.py` 中的 `BOLL` 类，确保它实现了所有四个抽象方法。
13. 读取文件 `tests/unit/test_kdj.py`。
14. 修改 `tests/unit/test_kdj.py` 中的断言逻辑，以修复 `KeyError`。
15. 读取文件 `tests/unit/test_indicators.py`。
16. 修改 `tests/unit/test_indicators.py` 中的 `test_ema_calculation` 测试，在使用 `ema` 变量前对其进行实例化以修复 `NameError`。 